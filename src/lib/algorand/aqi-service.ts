/**
 * Algorand AQI Service for the Air2Earth Frontend
 *
 * This module connects to the Algorand blockchain and fetches
 * AQI station data that was stored on-chain by the blockchain project.
 *
 * The data flow is:
 * 1. AQI data is stored on Algorand via box storage (blockchain project)
 * 2. This service reads the boxes from the smart contract
 * 3. The data is returned in the same format the frontend already uses
 *
 * This provides:
 * - Immutable data storage (can't be tampered with)
 * - Full audit trail (every change is a transaction)
 * - Decentralized access (anyone can read from the chain)
 * - Transparency (all data is publicly verifiable)
 */

import algosdk from 'algosdk';

// ─────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────

export interface AqiStationRaw {
  lat: number;
  lon: number;
  uid: number;
  aqi: string;
  station: {
    name: string;
    time: string;
  };
}

export interface AqiBoxData {
  lat: number;
  lon: number;
  uid: number;
  aqi: string;
  stationName: string;
  time: string;
  storedAt: string;
  txId?: string;
}

export interface TreeClaimData {
  treeId: string;
  planter: string;
  location: { lat: number; lon: number };
  variety: string;
  plantedAt: string;
  co2OffsetKg: number;
  evidenceUrl?: string;
  notes?: string;
}

export interface TreeBoxData extends TreeClaimData {
  storedAt: string;
  txId?: string;
}

export interface BlockchainAqiResponse {
  status: string;
  data: AqiStationRaw[];
  source: 'algorand-blockchain' | 'fallback-static';
  appId?: number;
  network?: string;
  fetchedAt: string;
}

// ─────────────────────────────────────────────────────────────
// Configuration
// ─────────────────────────────────────────────────────────────

// Try to load config from the JSON file generated during deployment
let BLOCKCHAIN_CONFIG: {
  appId: number;
  appAddress: string;
  network: string;
  algodServer: string;
  algodPort: number;
  algodToken: string;
} | null = null;

// Import the config JSON (generated by blockchain deploy script)
// Falls back to environment variables if not available
try {
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  const config = require('./config.json');
  BLOCKCHAIN_CONFIG = config;
} catch {
  console.warn(
    '[AlgorandAQI] config.json not found — using environment variables or defaults',
  );
}

function getAlgodClient(): algosdk.Algodv2 {
  const server =
    BLOCKCHAIN_CONFIG?.algodServer ||
    process.env.NEXT_PUBLIC_ALGOD_SERVER ||
    'http://localhost';
  const port =
    BLOCKCHAIN_CONFIG?.algodPort ||
    parseInt(process.env.NEXT_PUBLIC_ALGOD_PORT || '4001');
  const token =
    BLOCKCHAIN_CONFIG?.algodToken ||
    process.env.NEXT_PUBLIC_ALGOD_TOKEN ||
    'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';

  return new algosdk.Algodv2(token, server, port);
}

function getAppId(): bigint {
  const appId =
    BLOCKCHAIN_CONFIG?.appId ||
    parseInt(process.env.NEXT_PUBLIC_AQI_APP_ID || '0');

  if (!appId) {
    throw new Error(
      '[AlgorandAQI] No App ID configured. Run blockchain deploy first or set NEXT_PUBLIC_AQI_APP_ID',
    );
  }

  return BigInt(appId);
}

// ─────────────────────────────────────────────────────────────
// Core Functions
// ─────────────────────────────────────────────────────────────

/**
 * Fetch all AQI station data from the Algorand blockchain.
 *
 * Reads all box storage entries from the AQI Registry smart contract
 * and returns them in the standard API format.
 */
export async function fetchAqiFromBlockchain(): Promise<BlockchainAqiResponse> {
  try {
    const algod = getAlgodClient();
    const appId = getAppId();

    console.log(`[AlgorandAQI] Fetching AQI data from App ID: ${appId}`);

    // Get all box names from the application
    const boxesResponse = await algod.getApplicationBoxes(Number(appId)).do();
    const boxes = boxesResponse.boxes || [];

    console.log(`[AlgorandAQI] Found ${boxes.length} stations on-chain`);

    // Read each box value
    const stations: AqiStationRaw[] = [];

    for (const box of boxes) {
      try {
        // box.name is a Uint8Array
        const boxName = box.name;
        const boxResponse = await algod
          .getApplicationBoxByName(Number(appId), boxName)
          .do();
        const boxValue = boxResponse.value;

        // Decode the JSON data from bytes
        const jsonStr = new TextDecoder().decode(boxValue);
        const boxData: AqiBoxData = JSON.parse(jsonStr);

        // Convert to frontend format
        stations.push({
          lat: boxData.lat,
          lon: boxData.lon,
          uid: boxData.uid,
          aqi: boxData.aqi,
          station: {
            name: boxData.stationName,
            time: boxData.time,
          },
        });
      } catch (err) {
        console.warn(`[AlgorandAQI] Failed to read box:`, err);
      }
    }

    return {
      status: 'ok',
      data: stations,
      source: 'algorand-blockchain',
      appId: Number(appId),
      network: BLOCKCHAIN_CONFIG?.network || 'localnet',
      fetchedAt: new Date().toISOString(),
    };
  } catch (err) {
    console.error('[AlgorandAQI] Failed to fetch from blockchain:', err);
    throw err;
  }
}

/**
 * Fetch AQI data with automatic fallback to static data.
 *
 * Tries blockchain first; if it fails (e.g., LocalNet not running),
 * falls back to the hardcoded static data.
 */
export async function fetchAqiData(
  staticFallbackData?: AqiStationRaw[],
): Promise<BlockchainAqiResponse> {
  try {
    const blockchainData = await fetchAqiFromBlockchain();

    if (blockchainData.data.length > 0) {
      console.log(
        `[AlgorandAQI] ✅ Loaded ${blockchainData.data.length} stations from Algorand blockchain`,
      );
      return blockchainData;
    }

    throw new Error('No data found on blockchain');
  } catch (err) {
    console.warn(
      '[AlgorandAQI] ⚠️ Blockchain unavailable, using static fallback:',
      err,
    );

    if (staticFallbackData) {
      return {
        status: 'ok',
        data: staticFallbackData,
        source: 'fallback-static',
        fetchedAt: new Date().toISOString(),
      };
    }

    throw err;
  }
}

/**
 * Get a single station's data from the blockchain by UID.
 */
export async function fetchStationFromBlockchain(
  uid: number,
): Promise<AqiStationRaw | null> {
  try {
    const algod = getAlgodClient();
    const appId = getAppId();

    const boxName = new TextEncoder().encode(uid.toString());
    const boxResponse = await algod
      .getApplicationBoxByName(Number(appId), boxName)
      .do();

    const jsonStr = new TextDecoder().decode(boxResponse.value);
    const boxData: AqiBoxData = JSON.parse(jsonStr);

    return {
      lat: boxData.lat,
      lon: boxData.lon,
      uid: boxData.uid,
      aqi: boxData.aqi,
      station: {
        name: boxData.stationName,
        time: boxData.time,
      },
    };
  } catch {
    return null;
  }
}

/**
 * Check if the Algorand blockchain is reachable.
 */
export async function isBlockchainAvailable(): Promise<boolean> {
  try {
    const algod = getAlgodClient();
    await algod.status().do();
    return true;
  } catch {
    return false;
  }
}

/**
 * Look up global blockchain info
 */
export async function getBlockchainInfo() {
  try {
    const algod = getAlgodClient();
    const status = await algod.status().do();
    const info = await algod
      .accountInformation(BLOCKCHAIN_CONFIG?.appAddress || '')
      .do();

    return {
      round: status.lastRound,
      appId: getAppId().toString(),
      appAddress: BLOCKCHAIN_CONFIG?.appAddress,
      balance: Number(info.amount) / 1_000_000,
      network: BLOCKCHAIN_CONFIG?.network,
    };
  } catch {
    return null;
  }
}

// ─────────────────────────────────────────────────────────────
// Tree Planting (Carbon Claim) Helpers
// ─────────────────────────────────────────────────────────────

/**
 * Persists a new Tree Claim to the Algorand blockchain via the backend API.
 */
export async function storeTreeOnBlockchain(claim: TreeClaimData) {
  console.log('[AlgorandAQI] Requesting secure storage of tree:', claim.treeId);
  const res = await fetch('/api/tree', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(claim),
  });

  if (!res.ok) {
    const err = await res.json();
    throw new Error(err.error || 'Failed to store tree on blockchain');
  }

  return res.json();
}

/**
 * Fetches all Tree Claims from the blockchain by reading boxes prefixed with `tree-`.
 */
export async function fetchTreesFromBlockchain(): Promise<TreeBoxData[]> {
  try {
    const algod = getAlgodClient();
    const appId = getAppId();

    console.log(`[AlgorandAQI] Fetching Tree Claims for App ID: ${appId}`);
    const boxesResponse = await algod.getApplicationBoxes(Number(appId)).do();
    const boxes = boxesResponse.boxes || [];

    const trees: TreeBoxData[] = [];

    for (const box of boxes) {
      const boxName = new TextDecoder().decode(box.name);

      // Only process boxes starting with "tree-"
      if (boxName.startsWith('tree-')) {
        try {
          const boxResponse = await algod
            .getApplicationBoxByName(Number(appId), box.name)
            .do();
          const jsonStr = new TextDecoder().decode(boxResponse.value);
          const treeData: TreeBoxData = JSON.parse(jsonStr);
          trees.push(treeData);
        } catch (err) {
          console.warn(
            `[AlgorandAQI] Failed to read tree box ${boxName}:`,
            err,
          );
        }
      }
    }

    console.log(
      `[AlgorandAQI] ✅ Loaded ${trees.length} trees from blockchain`,
    );
    return trees;
  } catch (err) {
    console.error('[AlgorandAQI] Failed to fetch trees from blockchain:', err);
    throw err;
  }
}
